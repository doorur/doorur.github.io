<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Note</title>
    <description>Doorur</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 07 Apr 2019 16:11:37 +0900</pubDate>
    <lastBuildDate>Sun, 07 Apr 2019 16:11:37 +0900</lastBuildDate>
    <generator>Jekyll v3.8.4</generator>
    
      <item>
        <title>스프링 프레임워크의 IoC 컨테이너</title>
        <description>&lt;h3 id=&quot;1-ioc-컨테이너와-bean&quot;&gt;1. IoC 컨테이너와 Bean&lt;/h3&gt;
&lt;p&gt;스프링에서는 의존성을 주입받아 사용할 수 있습니다. 한 객체에서 사용하는 의존을 객체 자체가 결정하는게 아니라 객체 바깥에서 결정되기 때문에 제어의 역전(Inversion of Control)이라고 불리고, IoC라는 용어로 사용되고 있습니다.&lt;/p&gt;

&lt;p&gt;여기서 말하는 의존이란 한 객체가 동작하기 위해 필요한 어떤 것입니다. 예를 들어 다음과 같은 코드가 있다면 BookService 객체는 BookRepository라는 객체가 있어야 동작할 수 있고, BookRepository에 변경이 일어난다면 BookService 객체의 동작에도 변경이 일어나겠죠. 이때 BookService가 BookeRepository에 의존성을 가지고있다고 말합니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BookService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BookRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bookRepository&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BookRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;saveBook&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// bookRepository.save()의 동작에 변경이 있다면 이 메소드의 동작도 변경됩니다.&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bookRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;스프링 프레임워크는 IoC 컨테이너를 제공해서 컨테이너 안에 Bean들을 담아두었다가 필요한 곳에 주입시켜줄 수 있습니다. 그래서 다음과 같은 코드가 가능해집니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;
&lt;span class=&quot;nd&quot;&gt;@Service&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BookService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BookRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bookRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;saveBook&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bookRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;BookService 객체 안에서 new로 BookRepository 객체를 생성하지 않아도 BookService는 IoC컨테이너에 등록되어 있는 BookRepository 빈을 주입받아 사용할 수 있게 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;2-applicationcontext&quot;&gt;2. ApplicationContext&lt;/h3&gt;
&lt;p&gt;스프링에서 제공하는 IoC 컨테이너의 구현체는 ApplicationContext 인터페이스를 구현하고 있습니다. 또 ApplicationContext 인터페이스는 BeanFactory 인터페이스를 상속받고 있기 때문에 BeanFactory 인터페이스의 메소드인 getBean 통해서 IoC 컨테이너에 등록된 빈을 꺼내와 사용할 수도 있습니다. 이때 파라미터로 넘겨주는 값은 빈의 ID입니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;ApplicationContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;applicationContext&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AnnotationConfigApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ApplicationConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	
&lt;span class=&quot;n&quot;&gt;BookRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bookRepository&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BookRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;applicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getBean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bookRepository&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-bean을-설정하는-다양한-방법&quot;&gt;3. Bean을 설정하는 다양한 방법&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;여기서 설명하는 다섯가지 방법은 &lt;a href=&quot;https://github.com/doorur/spring-framework-core/commits/master&quot;&gt;깃허브&lt;/a&gt;에서 각각 커밋으로 코드를 확인할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;스프링은 2003년도에 처음 등장하면서 많은 개발자들이 사용해왔고 사용자들의 요구에 따라 여러 부분을 개선했습니다. IoC에 Bean을 등록하는 방법도 여러가지가 있는데 어떻게 발전해 왔는지 다섯 가지 방법을 알아보겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;첫번째-xml-config-파일에-빈-등록하기&quot;&gt;첫번째. xml config 파일에 빈 등록하기&lt;/h4&gt;
&lt;p&gt;xml config 파일에 프로젝트에서 사용할 모든 빈의 목록을 나열해주면 스프링 프레임워크가 이 xml 파일을 읽어서 IoC 컨테이너에 등록하는 방식입니다. 프로젝트가 커지면 커질 수록 등록해야할 빈도 많아져서 파일도 커지고 번거롭습니다.&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;beans&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bookService&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;me.doorur.springapplicationcontext.BookService&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bookRepository&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bookRepository&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
		  -- 여기서 name은 bookService에 있는 setter명
	  	  -- ref는 bookRepository의 beanId를 말한다
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bookRepository&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;me.doorur.springapplicationcontext.BookRepository&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;두번째-xml-config-파일을-이용해-컴포넌트-스캔하기&quot;&gt;두번째. xml config 파일을 이용해 컴포넌트 스캔하기&lt;/h4&gt;
&lt;p&gt;xml config 파일에 빈을 일일히 선언해주지 않고 각 객체에 @Component 어노테이션을 달아두면 어플리케이션이 로딩될 때 어노테이션을 단 객체를 빈으로 등록해주는 방법입니다. @Service, @Repository, @Controller 어노테이션은 각각 @Component 어노테이션을 상속받은 어노테이션이기 때문에 상기 어노테이션을 써도 컴포넌트 스캔할 때 빈으로 등록됩니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nd&quot;&gt;@Service&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;bookService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; 
&lt;span class=&quot;nd&quot;&gt;@Repository&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;bookRepository&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;beans&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;context:component-scan&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;base-package=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.doorur.springdemo&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
	  -- base-package에 명시해준 패키지 밑에 있는 모든 파일을 훑어 @Component가 있는 객체를 빈으로 등록합니다

&lt;span class=&quot;nt&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 방법은 빈을 일일히 등록해주지 않아도 되서 간편하지만 여전히 xml config 파일을 사용하는 방법입니다.&lt;/p&gt;

&lt;h4 id=&quot;세번째-java-config를-이용해서-빈-등록하기&quot;&gt;세번째. java config를 이용해서 빈 등록하기&lt;/h4&gt;
&lt;p&gt;xml config 파일을 사용하지 않고도 빈을 등록할 수 있습니다. @Configuration 어노테이션을 사용해서 자바 코드로 빈을 등록하는 방법입니다. 코드이기 때문에 IoC 컨테이너에 등록하기 전에 객체에 조작을 할 수 있어서 xml config 방식으로 빈을 등록하는 것보다 유연합니다.&lt;/p&gt;

&lt;p&gt;컴포넌트 스캔을 하지 않기 때문에 빈으로 등록할 객체에 @Component 어노테이션을 달아주지 않아도 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nd&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ApplicationConfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BookRepository&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bookRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;BookRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BookService&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bookService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;BookService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bookService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BookService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// 이렇게 빈으로 등록하기 전 객체에 조작을 가할 수 있습니다.&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;bookService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setBookRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bookRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bookService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;객체를 빈으로 등록할 때 위의 BookService의 예처럼 다른 빈을 의존성으로 가지고 있는 경우가 있습니다. 그럴 때는 위와 같이 직접 의존성의 메소드를 호출해서 사용할 수도 있고, 파라미터로 넘겨받을 수도 있습니다. 다음과 같이 파라미터에 선언을 해주면 알아서 주입받아 옵니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BookService&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bookService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BookRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bookRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;BookService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bookService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BookService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;bookService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setBookRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bookRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bookService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이때 주의할 점은 IoC에 등록되어 있지 않은 객체는 파라미터로 주입받을 수 없다는 점입니다. 하지만 선언 순서는 중요하지 않으니 어디선가 빈으로 등록되어 있기만 하다면 사용할 수 있습니다. (bookService 등록 후에 bookRepository를 등록해도 동작합니다.)&lt;/p&gt;

&lt;p&gt;이 방법은 xml config 파일을 사용하지 않아도 되고 빈에 조작을 할 수 있어 유용하지만 여전히 빈을 일일히 등록해줘야 합니다. 번거롭죠.&lt;/p&gt;

&lt;h4 id=&quot;네번째-java-config를-이용해서-컴포넌트-스캔하기&quot;&gt;네번째. java config를 이용해서 컴포넌트 스캔하기&lt;/h4&gt;
&lt;p&gt;자바 코드에서도 빈을 일일히 등록하지 않고 컴포넌트 스캔을 할 수 있습니다. @ComponentScan 어노테이션을 사용하면 @Component 어노테이션이 달린 객체들을 스캔해와서 빈으로 등록해 줍니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nd&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@ComponentScan&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;basePackages&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;com.doorur.demo&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ApplicationConfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;@Component 어노테이션을 달고 있는 클래스들을 스캔할 때는 @ComponentScan의 옵션인 basePackages에 정의 된 패키지를 기준으로 하위에 있는 클래스들을 탐색합니다. 컴포넌트를 선언한다고 해도 이 패키지 바깥에 있으면 빈으로 등록되지 않으니 이 부분을 주의해야 합니다.&lt;/p&gt;

&lt;h4 id=&quot;다섯번째-springbootapplication-어노테이션-사용하기&quot;&gt;다섯번째. @SpringBootApplication 어노테이션 사용하기&lt;/h4&gt;
&lt;p&gt;스프링 부트에서 제공하는 @SpringBootApplication은 @Configuration과 @ComponentScan을 포함하고 있습니다. 그래서 빈으로 등록하고자 하는 클래스에 @Component류의 어노테이션만 달아준다면 xml config 파일이나 java config 파일 없이도 IoC 컨테이너에 빈을 등록해서 사용할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nd&quot;&gt;@SpringBootApplication&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DemoApplication&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;왜-ioc-컨테이너에-빈을-등록해서-사용해야-할까&quot;&gt;왜 IoC 컨테이너에 빈을 등록해서 사용해야 할까?&lt;/h3&gt;
&lt;p&gt;그렇다면 객체들을 왜 자꾸 빈으로 만들어서 IoC 컨테이너에 등록해서 사용하는 걸까요? IoC 컨테이너에 등록하는 것에 여러가지 장점이 있습니다.&lt;/p&gt;

&lt;p&gt;가장 기본적인 이유는 변경에는 닫혀있고 확장에는 열려있는 구조를 위해서입니다. 객체지향의 5원칙(SOLID) 중에 하나인 OCP이죠. 의존성에 변경이 일어났을 때 그 객체를 사용하는 모든 부분을 수정하지 않고도 그 빈만 수정하면 됩니다. IoC로 관리하지 않았다면 객체를 new 해준 부분을 전부 수정해야합니다.&lt;/p&gt;

&lt;p&gt;이외에도 첫번째로 다른 빈에 주입하기 위해서입니다. 두번째로 다른 빈을 주입받기 위해서입니다. 세번째로 단위 테스트가 쉬운 코드를 만들기 위해서 입니다. 네번째로 객체를 여러개 생성할 필요 없이 한 인스턴스로만 사용하기 위해서 입니다. 다섯번째로 빈으로 등록되면 라이프사이클로 관리 되기 때문에 빈의 생성과 파괴 시점에 로직을 처리하기 용이하기 때문입니다. 기회가 된다면 이 이유들도 예제코드와 같이 블로깅 해보겠습니다.&lt;/p&gt;
</description>
        <pubDate>Sun, 07 Apr 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2019/04/07/spring-ioc/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/04/07/spring-ioc/</guid>
        
        <category>스프링</category>
        
        
      </item>
    
      <item>
        <title>더 나은 알고리즘 풀이를 생각하기</title>
        <description>&lt;h3 id=&quot;알고리즘-스터디&quot;&gt;알고리즘 스터디&lt;/h3&gt;
&lt;p&gt;작년 8월부터 기초 알고리즘 스터디를 하고있습니다. 책 &lt;a href=&quot;[알고리즘 문제 해결 전략](http://book.algospot.com/index.html)&quot;&gt;알고리즘 문제 해결전략&lt;/a&gt;에 나오는 문제를 일주일에 한 두 문제를 각자 푼 뒤, 모여서 풀이를 공유하는 스터디입니다.  문제의 난이도에 따라 손도 못 대는 문제가 있기도 하고, 풀었지만 시간초과인 문제, 오답인 문제, 한 번에 통과한 문제 등등 여러가지 경우가 있습니다.&lt;/p&gt;

&lt;p&gt;다른 사람은 어떻게 풀었는지 코드를 보고 이야기 나눌 수 있는게 이 스터디의 가장 좋은 점인 것 같아요. 문제 접근을 아예 색다르게 한 사람, 코드를 더 효율적으로 작성한 사람의 풀이를 볼 때 제일 재밌습니다.&lt;/p&gt;

&lt;p&gt;저는 주로 다른 사람의 풀이를 볼 때 내가 푼 방식과 얼마나 다른지, 저 코드에서 어떤 점을 차용해 오면 내 코드가 더 완성될 수 있는지를 주로 봤는데요. 스터디원 분 중에 한 분은 코드를 볼 때마다 개선점을 말해줬습니다. 예를들어 ‘for문을 두 번 돌릴 필요 없이 조건문 하나만 추가해 주면 훨씬 속도가 빨라질 것이다.’ 이런 식으로 매번 가이드를 해줬는데 이게 참 좋아보였습니다. 저한테는 없는 시각이었어요. 알고리즘 문제를 풀면서 자기가 작성한 코드에도 이런 시각을 가지면 좀 더 좋은 알고리즘을 작성할 수 있을 것 같았습니다. 실제로 그 스터디원 분은 거의 매번 가장 수행속도가 빠른 알고리즘으로 풀어오셨기도 했습니다.&lt;/p&gt;

&lt;h3 id=&quot;더-나은-풀이를-생각할-수-있는-방법&quot;&gt;더 나은 풀이를 생각할 수 있는 방법&lt;/h3&gt;
&lt;p&gt;마침 예전에 사두었던 책 &lt;a href=&quot;[코딩인터뷰 완전분석 - YES24](http://www.yes24.com/Product/goods/44305533)&quot;&gt;코딩 인터뷰 완전분석&lt;/a&gt;에 더 나은 문제풀이를 위한 전략이 소개되어 있어 그 내용을 설명해보겠습니다. 아래 내용은 &lt;a href=&quot;[7 Steps to Solve Algorithm Problems - YouTube](https://youtu.be/GKgAVjJxh9w)&quot;&gt;유투브&lt;/a&gt;와 &lt;a href=&quot;[Tips and Guidelines | Interview Preparation | HackerRank](https://www.hackerrank.com/interview/interview-preparation-kit/tips-and-guidelines/videos)&quot;&gt;해커랭크&lt;/a&gt;에서 원작자의 설명을 예시와 함께 (영어로) 들을 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;1-병목점bottleneck&quot;&gt;1. 병목점(Bottleneck)&lt;/h4&gt;
&lt;p&gt;알고리즘을 작성했고 더 최적화 하고 싶다면, 병목점(Bottleneck)이 어딘지 찾아야 합니다. 어느 로직에서 가장 시간이 많이 걸리는지를 알아야 알고리즘의 수행속도를 단축할 수 있습니다. O(N^2)인 부분을 두고 O(N)인 부분을 O(logN)으로 개선해봤자 전체적인 수행속도에 큰 영향을 줄 수 없기 때문이죠. 이 작업을 위해서 Big-O 시간을 계산할 줄 알아야 하고 알고리즘을 부분으로 나누어 생각할 수 있어야 합니다.&lt;/p&gt;

&lt;h4 id=&quot;2-불필요한-작업unnecessary-work&quot;&gt;2. 불필요한 작업(Unnecessary work)&lt;/h4&gt;
&lt;p&gt;생각보다 많은 경우, 알고리즘에 불필요한 작업이 숨어있습니다. 굳이 해주지 않아도 되는 처리를 반복해서 한다거나, 이미 정해져 있는 값을 찾기 위해 루프를 도는 등 불필요한 작업을 찾아 없애면 수행속도를 향상 시킬 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;3-중복-작업duplication-work&quot;&gt;3. 중복 작업(Duplication work)&lt;/h4&gt;
&lt;p&gt;경우에 따라서는 이미 한 작업을 중복해서 수행하는 알고리즘을 작성하기도 합니다. 피보나치 수열을 구현할 때 자주 등장하는 메모이제이션을 활용하지 않은 재귀가 유명한 예입니다. 이런 중복 작업을 찾아 없애면 알고리즘을 최적화 할 수 있습니다.&lt;/p&gt;
</description>
        <pubDate>Sat, 06 Apr 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2019/04/06/better-algorithm/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/04/06/better-algorithm/</guid>
        
        <category>알고리즘</category>
        
        
      </item>
    
  </channel>
</rss>
